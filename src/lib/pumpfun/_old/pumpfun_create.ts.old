// pumpfun_create.ts

import { Commitment, Connection, Finality, Keypair, PublicKey, SystemProgram, SYSVAR_RENT_PUBKEY, Transaction, TransactionInstruction, VersionedTransactionResponse } from "@solana/web3.js";
import { getAssociatedTokenAddress, TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from "@solana/spl-token";
import { MPL_TOKEN_METADATA_PROGRAM_ID } from "@metaplex-foundation/mpl-token-metadata";

import { calculateWithSlippageBuy, CreateTokenMetadata, FEE_RECIPIENT, getGlobalAccountPubKey, METADATA_SEED, PUMPFUN_PROGRAM_ID } from "./pumpfun_create_buy_sell";
import { getBuyInstructions } from "./pumpfun_buy";
import { DEFAULT_COMMITMENT, DEFAULT_FINALITY, sendTx } from "./pumpfun_tx";
import { getGlobalAccount } from "./pumpfun_global_account";
import { getBondingCurvePDA } from "./pumpfun_bondingcurve_account";
import { sendVersionedTransaction } from "../solana/transaction";




/* ######################################################### */


export async function pumpFunCreateAndBuy(
    connection: Connection,
    creator: Keypair,
    mint: Keypair,
    newTokenMetadata: CreateTokenMetadata,
    buyAmountSol: bigint,
    slippageBasisPoints: bigint = 500n,
    priorityFees?: PriorityFee,
    commitment: Commitment = DEFAULT_COMMITMENT,
    finality: Finality = DEFAULT_FINALITY
): Promise<TransactionResult> {

    // Upload des Metadata sur IPFS
    let tokenMetadata = await createTokenMetadata(newTokenMetadata);


    // Construction de l'instruction "create"
    let createTx = await getCreateInstructions(
        connection,
        creator.publicKey,
        newTokenMetadata.name,
        newTokenMetadata.symbol,
        tokenMetadata.metadataUri,
        mint
    );

    let newTx = new Transaction().add(createTx);

    if (buyAmountSol > 0) {
        const globalAccount = await getGlobalAccount(connection, commitment);
        const buyAmount = globalAccount.getInitialBuyPrice(buyAmountSol);
        const buyAmountWithSlippage = calculateWithSlippageBuy(
            buyAmountSol,
            slippageBasisPoints
        );


        // Construction de l'instruction "buy"
        const buyTx = await getBuyInstructions(
            connection,
            creator.publicKey,
            mint.publicKey,
            FEE_RECIPIENT /*globalAccount.feeRecipient */,
            buyAmount,
            buyAmountWithSlippage
        );

        newTx.add(buyTx);
    }


    // Construction de la transaction finale
    let createResults = await sendTx(
        connection,
        newTx,
        creator.publicKey,
        [creator, mint],
        priorityFees,
        commitment,
        finality
    );

    //const createResults: TransactionResult = await sendVersionedTransaction(connection, creator, newTx); // requiert typeof newTx = VersionedTransaction

    return createResults;
}




//create token instructions
async function getCreateInstructions(
    connection: Connection,
    creator: PublicKey,
    name: string,
    symbol: string,
    uri: string,
    mint: Keypair,
    commitment: Commitment = DEFAULT_COMMITMENT
) {
    // Inf√©rer le programme de token pour ce mint
    const tokenProgramId = TOKEN_2022_PROGRAM_ID; //await inferTokenProgram(connection, mint, commitment);

    const mplTokenMetadata = new PublicKey(MPL_TOKEN_METADATA_PROGRAM_ID);

    const [metadataPDA] = PublicKey.findProgramAddressSync(
        [
            Buffer.from(METADATA_SEED),
            mplTokenMetadata.toBuffer(),
            mint.publicKey.toBuffer(),
        ],
        mplTokenMetadata
    );

    const associatedBondingCurve = await getAssociatedTokenAddress(
        mint.publicKey,
        getBondingCurvePDA(mint.publicKey),
        true
    );



    //const globalAccount = await getGlobalAccount(connection, commitment);
    //const globalAccountPubKey = globalAccount.feeRecipient;
    const globalAccountPubKey = FEE_RECIPIENT; //getGlobalAccountPubKey();


    // Cr√©er l'instruction manuellement avec les bons programmes
    const createInstruction = preparePumpFunCreateInstruction(
        globalAccountPubKey,
        mint,
        associatedBondingCurve,
        creator,
        metadataPDA,
        name,
        symbol,
        uri,
        tokenProgramId // Passer le programme de token d√©tect√©
    );

    //const createInstruction = program.methods
    //    .create(name, symbol, uri)
    //    .accounts({
    //        mint: mint.publicKey,
    //        associatedBondingCurve: associatedBondingCurve,
    //        metadata: metadataPDA,
    //        user: creator,
    //    })
    //    .signers([mint])
    //    .transaction()

    return createInstruction;
}




export function preparePumpFunCreateInstruction(
    feeRecipient: PublicKey,
    mint: Keypair,
    associatedBondingCurve: PublicKey,
    creator: PublicKey,
    metadataPDA: PublicKey,
    name: string,
    symbol: string,
    uri: string,
    tokenProgramId: PublicKey = TOKEN_PROGRAM_ID
): TransactionInstruction {
    console.log(`üîß Pr√©paration manuelle de l'instruction de cr√©ation de token...`);
    console.log(`üè∑Ô∏è Nom: ${name}, Symbole: ${symbol}`);
    console.log(`üîë Utilisation du programme de token: ${tokenProgramId.toBase58()}`);

    // Identifiant de l'instruction create
    const INSTRUCTION_IDENTIFIER = Buffer.from([24, 30, 200, 40, 5, 28, 7, 119]);

    // Encoder les cha√Ænes en tampons
    const nameBuffer = Buffer.from(name);
    const nameLength = Buffer.alloc(4);
    nameLength.writeUInt32LE(nameBuffer.length, 0);

    const symbolBuffer = Buffer.from(symbol);
    const symbolLength = Buffer.alloc(4);
    symbolLength.writeUInt32LE(symbolBuffer.length, 0);

    const uriBuffer = Buffer.from(uri);
    const uriLength = Buffer.alloc(4);
    uriLength.writeUInt32LE(uriBuffer.length, 0);

    // Concat√©ner les donn√©es de l'instruction
    const instructionData = Buffer.concat([
        INSTRUCTION_IDENTIFIER,
        nameLength,
        nameBuffer,
        symbolLength,
        symbolBuffer,
        uriLength,
        uriBuffer
    ]);

    const globalAccountPubKey = getGlobalAccountPubKey();
    const bondingCurvePDA = getBondingCurvePDA(mint.publicKey);

    console.log(`üåê Compte global: ${globalAccountPubKey.toBase58()}`);
    console.log(`üîÑ Bonding curve PDA: ${bondingCurvePDA.toBase58()}`);

    // Liste des comptes requis - bas√©e sur la transaction r√©ussie
    const keys = [
        { pubkey: mint.publicKey, isSigner: true, isWritable: true },
        { pubkey: feeRecipient, isSigner: false, isWritable: true },
        { pubkey: bondingCurvePDA, isSigner: false, isWritable: true },
        { pubkey: associatedBondingCurve, isSigner: false, isWritable: true },
        { pubkey: metadataPDA, isSigner: false, isWritable: true },
        { pubkey: creator, isSigner: true, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: tokenProgramId, isSigner: false, isWritable: false },
        { pubkey: new PublicKey(MPL_TOKEN_METADATA_PROGRAM_ID), isSigner: false, isWritable: false },
        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
        { pubkey: globalAccountPubKey, isSigner: false, isWritable: false }
    ];

    console.log(`üìë Liste des comptes pr√©par√©e avec ${keys.length} comptes`);

    return new TransactionInstruction({
        keys,
        programId: new PublicKey(PUMPFUN_PROGRAM_ID),
        data: instructionData
    });
}


